// checksum 0x78c version 0x60010
/*
  This file was generated by the Qt Quick Application wizard of Qt Creator.
  QmlApplicationViewer is a convenience class containing mobile device specific
  code such as screen orientation handling. Also QML paths and debugging are
  handled here.
  It is recommended not to modify this file, since newer versions of Qt Creator
  may offer an updated version of it.
*/

#include "qmlapplicationviewer.h"

#include <QtCore/QDir>
#include <QtCore/QFile>
#include <QtCore/QFileInfo>
#include <QtDeclarative/QDeclarativeComponent>
#include <QtDeclarative/QDeclarativeEngine>
#include <QtDeclarative/QDeclarativeContext>
#include <QtGui/QApplication>

#include <QX11Info>
#include <X11/Xlib.h>
#include <X11/Xatom.h>

#include <qplatformdefs.h> // MEEGO_EDITION_HARMATTAN

#ifdef HARMATTAN_BOOSTER
#include <MDeclarativeCache>
#endif

#if defined(QMLJSDEBUGGER) && QT_VERSION < 0x040800

#include <qt_private/qdeclarativedebughelper_p.h>

#if !defined(NO_JSDEBUGGER)
#include <jsdebuggeragent.h>
#endif
#if !defined(NO_QMLOBSERVER)
#include <qdeclarativeviewobserver.h>
#endif

// Enable debugging before any QDeclarativeEngine is created
struct QmlJsDebuggingEnabler
{
    QmlJsDebuggingEnabler()
    {
        QDeclarativeDebugHelper::enableDebugging();
    }
};

// Execute code in constructor before first QDeclarativeEngine is instantiated
static QmlJsDebuggingEnabler enableDebuggingHelper;

#endif // QMLJSDEBUGGER

class QmlApplicationViewerPrivate
{
    QmlApplicationViewerPrivate(QDeclarativeView *view_) : view(view_) {}

    QString mainQmlFile;
    QDeclarativeView *view;
    friend class QmlApplicationViewer;
    QString adjustPath(const QString &path);
};

QString QmlApplicationViewerPrivate::adjustPath(const QString &path)
{
#ifdef Q_OS_UNIX
#ifdef Q_OS_MAC
    if (!QDir::isAbsolutePath(path))
        return QCoreApplication::applicationDirPath()
                + QLatin1String("/../Resources/") + path;
#else
    QString pathInInstallDir;
    const QString applicationDirPath = QCoreApplication::applicationDirPath();
    pathInInstallDir = QString::fromAscii("%1/../%2").arg(applicationDirPath, path);

    if (QFileInfo(pathInInstallDir).exists())
        return pathInInstallDir;
#endif
#endif
    return path;
}

QmlApplicationViewer::QmlApplicationViewer(QWidget *parent)
    : QDeclarativeView(parent)
    , d(new QmlApplicationViewerPrivate(this))
{
    connect(engine(), SIGNAL(quit()), SLOT(close()));
    setResizeMode(QDeclarativeView::SizeRootObjectToView);
    // Qt versions prior to 4.8.0 don't have QML/JS debugging services built in
#if defined(QMLJSDEBUGGER) && QT_VERSION < 0x040800
#if !defined(NO_JSDEBUGGER)
    new QmlJSDebugger::JSDebuggerAgent(d->view->engine());
#endif
#if !defined(NO_QMLOBSERVER)
    new QmlJSDebugger::QDeclarativeViewObserver(d->view, d->view);
#endif
#endif
}

QmlApplicationViewer::QmlApplicationViewer(QDeclarativeView *view, QWidget *parent)
    : QDeclarativeView(parent)
    , d(new QmlApplicationViewerPrivate(view))
{
    connect(view->engine(), SIGNAL(quit()), view, SLOT(close()));
    view->setResizeMode(QDeclarativeView::SizeRootObjectToView);
    // Qt versions prior to 4.8.0 don't have QML/JS debugging services built in
#if defined(QMLJSDEBUGGER) && QT_VERSION < 0x040800
#if !defined(NO_JSDEBUGGER)
    new QmlJSDebugger::JSDebuggerAgent(d->view->engine());
#endif
#if !defined(NO_QMLOBSERVER)
    new QmlJSDebugger::QDeclarativeViewObserver(d->view, d->view);
#endif
#endif
}

QmlApplicationViewer::~QmlApplicationViewer()
{
    delete d;
}

QmlApplicationViewer *QmlApplicationViewer::create()
{
#ifdef HARMATTAN_BOOSTER
    return new QmlApplicationViewer(MDeclarativeCache::qDeclarativeView(), 0);
#else
    return new QmlApplicationViewer();
#endif
}

void QmlApplicationViewer::setMainQmlFile(const QString &file)
{
    Atom atomMInvokedBy = XInternAtom(QX11Info::display(), "_MEEGOTOUCH_WM_INVOKED_BY", False);
    Display *display = QX11Info::display();
    XChangeProperty(display, d->view->winId(), atomMInvokedBy, XA_WINDOW, 32, PropModeReplace, (unsigned char *)&parentWindowId, 1);
    XSetTransientForHint(display, d->view->winId(), parentWindowId);
    Atom atomWindowType = XInternAtom(QX11Info::display(), "_MEEGOTOUCH_NET_WM_WINDOW_TYPE_MAPPLICATION", False);
    XChangeProperty(QX11Info::display(), d->view->winId(),
                    XInternAtom(QX11Info::display(), "_NET_WM_WINDOW_TYPE", False),
                    XA_ATOM, 32, PropModeAppend, (unsigned char*) &atomWindowType, 1);

    d->view->rootContext()->setContextProperty("actor", this);
    d->view->rootContext()->setContextProperty("unamenumeric", QVariant::fromValue(true));
    d->view->rootContext()->setContextProperty("xservice", QString(XSERVICE));
    d->view->rootContext()->setContextProperty("serverset", QVariant(false));
    d->view->rootContext()->setContextProperty("encryptionset", QVariant(false));
    d->view->rootContext()->setContextProperty("extratextvisible", QVariant(false));
    d->mainQmlFile = d->adjustPath(file);
    d->view->setSource(QUrl::fromLocalFile(d->mainQmlFile));
    QObject* themeObject = qvariant_cast<QObject*>(d->view->rootContext()->contextProperty("theme"));
    if ( themeObject )
       themeObject->setProperty("inverted", true);

    QObject* screenObject = qvariant_cast<QObject*>(d->view->rootContext()->contextProperty("screen"));
    if ( screenObject )
       screenObject->setProperty("allowedOrientations", 1);

}

void QmlApplicationViewer::addImportPath(const QString &path)
{
    d->view->engine()->addImportPath(d->adjustPath(path));
}

void QmlApplicationViewer::setOrientation(ScreenOrientation orientation)
{
#if defined(Q_OS_SYMBIAN)
    // If the version of Qt on the device is < 4.7.2, that attribute won't work
    if (orientation != ScreenOrientationAuto) {
        const QStringList v = QString::fromAscii(qVersion()).split(QLatin1Char('.'));
        if (v.count() == 3 && (v.at(0).toInt() << 16 | v.at(1).toInt() << 8 | v.at(2).toInt()) < 0x040702) {
            qWarning("Screen orientation locking only supported with Qt 4.7.2 and above");
            return;
        }
    }
#endif // Q_OS_SYMBIAN

    Qt::WidgetAttribute attribute;
    switch (orientation) {
#if QT_VERSION < 0x040702
    // Qt < 4.7.2 does not yet have the Qt::WA_*Orientation attributes
    case ScreenOrientationLockPortrait:
        attribute = static_cast<Qt::WidgetAttribute>(128);
        break;
    case ScreenOrientationLockLandscape:
        attribute = static_cast<Qt::WidgetAttribute>(129);
        break;
    default:
    case ScreenOrientationAuto:
        attribute = static_cast<Qt::WidgetAttribute>(130);
        break;
#else // QT_VERSION < 0x040702
    case ScreenOrientationLockPortrait:
        attribute = Qt::WA_LockPortraitOrientation;
        break;
    case ScreenOrientationLockLandscape:
        attribute = Qt::WA_LockLandscapeOrientation;
        break;
    default:
    case ScreenOrientationAuto:
        attribute = Qt::WA_AutoOrientation;
        break;
#endif // QT_VERSION < 0x040702
    };
    setAttribute(attribute, true);
}

void QmlApplicationViewer::showExpanded()
{

#if defined(Q_OS_SYMBIAN) || defined(MEEGO_EDITION_HARMATTAN) || defined(Q_WS_SIMULATOR)
    d->view->showFullScreen();
#elif defined(Q_WS_MAEMO_5)
    d->view->showMaximized();
#else
    d->view->show();
#endif
}

QApplication *createApplication(int &argc, char **argv)
{
#ifdef HARMATTAN_BOOSTER
    return MDeclarativeCache::qApplication(argc, argv);
#else
    return new QApplication(argc, argv);
#endif
}

void QmlApplicationViewer::desktopIcon(bool visible)
{
    if (visible)
    {
        system(QString("echo \"[Desktop Entry]\" > /home/user/.local/share/applications/%1.desktop").arg(QString(XSERVICE)).toAscii());
        system(QString("echo \"Type=Application\" >> /home/user/.local/share/applications/%1.desktop").arg(QString(XSERVICE)).toAscii());
        system(QString("echo \"Name=%1\" >> /home/user/.local/share/applications/%1.desktop").arg(QString(XSERVICE)).toAscii());
        system(QString("echo \"X-MeeGo-Logical-Id=qtn_%1_name\" >> /home/user/.local/share/applications/%1.desktop").arg(QString(XSERVICE)).toAscii());
        system(QString("echo \"X-MeeGo-Translation-Catalog=extraplugins\" >> /home/user/.local/share/applications/%1.desktop").arg(QString(XSERVICE)).toAscii());
        system(QString("echo \"Icon=%1\" >> /home/user/.local/share/applications/%2.desktop").arg(qtTrId(QString("qtn_%1_icon").arg(QString(XSERVICE)).toAscii())).arg(QString(XSERVICE)).toAscii());
        system(QString("echo \"OnlyShownIn=X-MeeGo\" >> /home/user/.local/share/applications/%1.desktop").arg(QString(XSERVICE)).toAscii());
        system(QString("echo \"Exec=dbus-send --session --print-reply --type=\\\"method_call\\\" --dest=com.nokia.maemo.meegotouch.Contacts  / com.nokia.maemo.meegotouch.ContactsInterface.openContactListForService string:\\\"%1\\\"\" >> /home/user/.local/share/applications/%1.desktop").arg(QString(XSERVICE)).toAscii());
    }
    else
        system(QString("rm /home/user/.local/share/applications/%1.desktop").arg(QString(XSERVICE)).toAscii());
}

void QmlApplicationViewer::init(int type)
{
    initType = type;
    d->view->rootContext()->setContextProperty("initType", initType);
    d->view->rootContext()->setContextProperty("onloadbusy", QVariant(initType==1));

    manager = new Accounts::Manager(QString("IM"));
    service = manager->service(QString(XSERVICE));

    mAM = AccountManager::create();
    connect(mAM->becomeReady(),
            SIGNAL(finished(Tp::PendingOperation *)),
            SLOT(onReadyLoad(Tp::PendingOperation *)));
}

void QmlApplicationViewer::onReadyLoad(Tp::PendingOperation *op)
{
    if (op->isError())
        qWarning() << "onReadyLoad error:" << op->errorName() << ": " << op->errorMessage();

    if (initType==1 && accountx!=NULL)
    {
        mainservice = accountx->selectedService();
        accountx->selectService(service);
        QString uid = accountx->valueAsString("tmc-uid");
        mAccSet = mAM->validAccounts();
        for (int i=0; i<mAccSet->accounts().count(); i++)
        {
            if (mAccSet->accounts()[i]->uniqueIdentifier() == uid)
            {
                mAcc = mAccSet->accounts()[i];
                QVariantMap parameters = mAcc->parameters();
                d->view->rootContext()->setContextProperty("displaynametext", mAcc->displayName());
                d->view->rootContext()->setContextProperty("usernametext", parameters.value("account",""));
                d->view->rootContext()->setContextProperty("passwordtext", parameters.value("password",""));
//                d->view->rootContext()->setContextProperty("servertext", parameters.value("server",""));
                d->view->rootContext()->setContextProperty("porttext", parameters.value("port",""));
//                d->view->rootContext()->setContextProperty("encryptionvalue", parameters.value("require-encryption",""));
                d->view->rootContext()->setContextProperty("showiconvalue", QVariant(QFile(QString("/home/user/.local/share/applications/%1.desktop").arg(QString(XSERVICE))).exists()));
                d->view->rootContext()->setContextProperty("enabledvalue", QVariant(mAcc->isEnabled()));
                break;
            }
        }
    }

    d->view->rootContext()->setContextProperty("onloadbusy", QVariant(false));
}

void QmlApplicationViewer::saveAccount(QString dname,
                                       QString uname,
                                       QString pword,
                                       QString server,
                                       QString port,
                                       QVariant encryption,
                                       QVariant dicon,
                                       QVariant aenabled)
{
    QVariantMap parameters = mAcc->parameters();
    QStringList unset;

    parameters["account"]=uname;
    parameters["password"]=pword;
    if (port.length()==0)
    {
        parameters["port"]=(uint)5190;
    }
    else
        parameters["port"]=port.toUInt();
    desktopIcon(dicon.toBool());

    dataUpdated = false;

    if (mAcc->isEnabled() != aenabled.toBool())
    {
        accountx->selectService(mainservice);
        accountx->setEnabled(aenabled.toBool());
        accountx->sync();
    }

    connect(mAcc->updateParameters(parameters, unset),
            SIGNAL(finished(Tp::PendingOperation *)),
            SLOT(onUpdateParameters(Tp::PendingOperation *)));

    connect(mAcc->setDisplayName(dname),
            SIGNAL(finished(Tp::PendingOperation *)),
            SLOT(onDisplaynameChanged(Tp::PendingOperation *)));

    accountx->selectService(mainservice);
    accountx->setValue("name", dname);
    accountx->setValue("username", uname);
    accountx->setValue("password", pword);
    accountx->sync();
}

void QmlApplicationViewer::onUpdateParameters(Tp::PendingOperation *op)
{
    if (op->isError())
        qWarning() << "onUpdateParameters error:" << op->errorName() << ": " << op->errorMessage();

    if (dataUpdated)
        exit(0);
    else
        dataUpdated = true;
}

void QmlApplicationViewer::onDisplaynameChanged(Tp::PendingOperation *op)
{
    if (op->isError())
        qWarning() << "onDisplaynameChanged error:" << op->errorName() << ": " << op->errorMessage();

    if (dataUpdated)
        exit(0);
    else
        dataUpdated = true;
}

void QmlApplicationViewer::deleteAccount()
{
    if (accountx != NULL)
    {
        dataUpdated = false;
        desktopIcon(false);

        connect(accountx,
                SIGNAL(removed()),
                SLOT(onAccountxRemoved()));

        accountx->selectService(service);
        mAccSet = mAM->validAccounts();
        for (int i=0; i<mAccSet->accounts().count(); i++)
        {
            if (mAccSet->accounts()[i]->uniqueIdentifier() == accountx->valueAsString("tmc-uid"))
            {
                connect(mAccSet->accounts()[i]->remove(),
                        SIGNAL(finished(Tp::PendingOperation *)),
                        SLOT(onAccountRemoved(Tp::PendingOperation *)));
                break;
            }
        }
        accountx->remove();
        accountx->sync();
    }
    else
        qWarning() << "deleteAccount error: accountx is NULL";
}

void QmlApplicationViewer::onAccountRemoved(Tp::PendingOperation *op)
{
    if (op->isError())
        qWarning() << "onAccountRemoved error:" << op->errorName() << ": " << op->errorMessage();

    if (dataUpdated)
        exit(0);
    else
        dataUpdated = true;
}

void QmlApplicationViewer::onAccountxRemoved()
{
    if (dataUpdated)
        exit(0);
    else
        dataUpdated = true;
}

void QmlApplicationViewer::createAccount(QVariant dname,
                                         QVariant uname,
                                         QVariant pword,
                                         QVariant dicon)
{
    paramsSet << dname;
    paramsSet << uname;
    paramsSet << pword;

    desktopIcon(dicon.toBool());

    connect(manager,
            SIGNAL(accountCreated(Accounts::AccountId)),
            SLOT(onAccountxCreated(Accounts::AccountId)));

    accountx = manager->createAccount(QString(XSERVICE));
    accountx->sync();
}

void QmlApplicationViewer::onAccountxCreated(Accounts::AccountId id)
{
    QVariantMap params;
    params.insert("account", paramsSet[1].toString());
    params.insert("password", paramsSet[2].toString());
    connect(mAM->createAccount(QString("haze"),
                               QString("icq"),
                               paramsSet[0].toString(),
                               params),
            SIGNAL(finished(Tp::PendingOperation *)),
            SLOT(onAccountCreated(Tp::PendingOperation *)));

}

void QmlApplicationViewer::onAccountCreated(Tp::PendingOperation *op)
{
    if (op->isError())
        qWarning() << "onAccountCreated error:" << op->errorName() << ": " << op->errorMessage();

    PendingAccount *pacc =
        qobject_cast<PendingAccount *>(op);
    mAcc = pacc->account();
    mAcc->setEnabled(true);

    connect(accountx,
            SIGNAL(synced()),
            SLOT(onSynced()));

    QString uid = mAcc->uniqueIdentifier();
    accountx->setValue("name", paramsSet[0]);
    accountx->setValue("username", paramsSet[1]);
    accountx->setValue("password", paramsSet[2]);
    accountx->setEnabled(true);
    accountx->selectService(service);
    accountx->setEnabled(true);
    accountx->setValue("tmc-uid", uid);
    accountx->sync();
}

void QmlApplicationViewer::onSynced()
{
    exit(0);
}
